---
layout: post
title: UI树
---
Cocos2d-x支持在屏幕上绘制精灵、文本、形状、粒子、地图等，所有这些元素都继承自Node类。Node类定义了一个元素的布局、变换、坐标系统等属性。Cocos2d-x中采用二叉树来组织管理一个场景中的所有UI元素，称为UI树。UI树的根节点为Scene类，其每一个节点都是一个Node实例对象。对UI树进行遍历可以决定元素的被绘制顺序和模型视图变换矩阵的计算。Cocos2d-x使用localZOrder来表示元素的逻辑深度，UI树采用中序遍历。一个元素的逻辑深度是一个局部概念，只在其父节点和兄弟节点之间有意义。

##Cocos2d-x整体框架
###游戏生命周期
###场景管理
一个场景是一个以Scene为根节点的UI树。每个时刻最多只有一个当前场景在运行，Director管理当前运行的场景，并提供在不同场景间切换的方法。
Director提供了两种方法从一个场景切换到另一个场景。一种是使用replaceScene()方法直接替换，这会删除并释放之前的场景；另一种则通过pushScene和popScene方法进行，这种方法不会删除之前的场景。

###游戏循环
每一帧循环的执行动作：用户输入，动画计算，物理模拟，游戏逻辑更新，UI遍历，绘制，交换缓冲区，自动释放。
#Cocos2d-x3.0的绘制系统

cocos2d-x3.0的绘制系统实现了元素与绘制逻辑的分离。我们知道，由于每一个UI元素都是Node类的实例对象，都实现了一个draw()方法，而实际中draw()方法仅仅向render发送RenderCommand绘制命令。这个动作不会执行任何的GL绘制，而是将RenderCommand放入一个RenderQueue栈中。等到所有UI元素遍历结束后，render首先对绘制命令进行排序，排序的主要依据是globalZOrder，最后才开始执行绘制命令。
因此，绘制流程可以划分为3个阶段，分别是：

1. 生成绘制命令RenderCommand

2. 对绘制命令进行排序

3. 执行绘制命令

对于一般的RenderCommand，按照顺序执行绘制。对于相邻且使用相同纹理和着色器的QuadCommand的精灵元素，render会将他们组合在一起，这样可以之调用一次绘制命令，从而减少OpenGL ES的绘制次数，提高性能。
