---
layout: post
title: Java native Interface
---

##简介

许多时候，我们需要用到原生代码（C/C++）来解决java中的一些内存管理或者是效率问题。java通过JNI来
支持原生代码。

##准备开始
### JNI与C
*第一步，在java类中使用C代码-HelloJNI.java*

    public class HelloJNI {
       static {
          System.loadLibrary("hello"); // Load native library at runtime
                                       // hello.dll (Windows) or libhello.so (Unixes)
       }
     
       // Declare a native method sayHello() that receives nothing and returns void
       private native void sayHello();
     
       // Test Driver
       public static void main(String[] args) {
          new HelloJNI().sayHello();  // invoke the native method
       }
    }

这个静态加载器包括一句System.loadLibrary()，用来在加载类的时候加载原生动态库“Hello”。“Hello”
对应Windows中的hello.dll文件或者Unix中的libhello.so文件。动态库需要放置在java的库文件路径中。
否则的话，程序会抛出UnsatisfiedLinkError。

*native*关键字用于将sayHello()方法声明为原生方法，也就是一个由其它语言实现的方法。java中的原生方法
没有函数体。其函数体在原生库中实现。

然后将“HelloJNI.java”编译为“HelloJNI.class”

    javac HelloJNI.java

*第二步，创建C/C++头文件 - HelloJNI.h*

对生成的class文件运行javah生成C/C++头文件。

    javah HelloJNI

生成的结果是一个HelloJNI.h的头文件

    /* DO NOT EDIT THIS FILE - it is machine generated */
    #include <jni.h>
    /* Header for class HelloJNI */
     
    #ifndef _Included_HelloJNI
    #define _Included_HelloJNI
    #ifdef __cplusplus
    extern "C" {
    #endif
    /*
     * Class:     HelloJNI
     * Method:    sayHello
     * Signature: ()V
     */
    JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *, jobject);
     
    #ifdef __cplusplus
    }
    #endif
    #endif
