---
layout: post
title:  Cocos2d-x的内存管理机制
---
由于自己一直都是用lua语言在cocos2d-x上工作。这一方面提升了工作的效率，但不好的一点是对于直接从lua上手cocos2d-x的人来说，这屏蔽了许多引擎工作的细节。这其中，cocos2d-x的内存管理机制就是很重要的一块。完整地理解和正确地使用cocos2d-x的内存管理机制是学好cocos2d-x的基础工作。

## 引用计数
cocos2d-x的内存管理的基础是引用计数。cocos2d-x中的所有对象几乎都继承自Ref基类，Ref基类主要用于引用计数管理，它实现了retain()和release()方法来增加和减少对象的引用计数，如果引用计数为零，执行delete将内存释放。如此，在cocos2d-x中需要解决的问题就变成了如何自动调用retain()和release()方法了。

##autorelease
cocos2d-x通过对一个对象指针执行autorelease()方法将其加入到一个AutoreleasePool中，并在游戏的每一帧结束时，对AutoreleasePool中的对象执行release()方法。
1. **这种方法可以称作autorelease方法管理内存**

2. _autorelease()类似于创建了一个共享的智能指针_，作用域为一帧，在该帧结束后，将释放自己的引用计数。

3. 所以，autorelease方式管理内存，变量本身没有自主控制权，而是统一由autoreleasePool进行管理的，是一种弱引用关系。

4. 这种方式适合用于UI元素内存管理。

##RefPtr智能指针
1. RefPtr<T>在对象的构造函数中分配内存，在对象的析构函数中释放内存。

2. RefPtr<T>的构造函数（包括复制构造函数）会对任何不是nullptr的Ref指针增加引用计数。

3. 适用于单个的非集合元素，比如游戏种的数据。

##UI元素的内存管理
cocos2d-x的所有UI元素都实现了create()静态方法来返回一个autorelease对象。创建一个Node对象时，其引用计数为1，并加入当前AutoreleasePool，当前帧结束时会调用release()释放一次。如果将Node加入UI树中，Node会被插入Vector<T>中，Vector<T>会对插入的元素执行retian()方法，并在移除元素时执行release()方法，这样在一帧结束时Node的引用计数仍为1，将不会被释放，而Node被移出UI树时，将会被释放。

    Node * Node::create(void)
    {
        Node * ret = new Node();
        if(ret && ret->init()){
            ret->autorelease();
        }
        else{
            CC_SAFE_DELETE(ret);
        }
        return ret;
    }

---
#纹理缓存管理

纹理占据着游戏的大部分内存，对于纹理对内存的占用的管理直接影响游戏的性能。一方面，可以通过选择适当的图片格式或者使用压缩纹理来减少队里对内存的占用。另一方面，需要对纹理的生命周期进行管理，以便于在使用时能够实时调用，而在用完后可以及时销毁。

1. 一个纹理在使用期间应该只创建一次

2. 尽量避免动态加载纹理

##TextureCache
TextureCache是一个单例模式，对于每个Director只有一个实例。负责Cocos2d-x中纹理的创建、缓存和删除。在Cocos2d-x中，一个纹理对应一个Texture2D实例，创建一个Texture2D实例会将相应的数据加载到GPU内存中，而销毁Texture2D实例时则会将纹理数据从GPU内存中移除，这就构成了一个纹理的生命周期。

TextureCache使用引用计数管理其中的纹理，也就是Texture2D对象。所有的空闲纹理的引用计数都是1，而正在被使用的纹理的引用计数则等于使用它的元素个数加1。TextureCache开放了removeUnusedTextures()方法移除空闲纹理，removeTexture(Texture2D * texures)方法移除指定纹理，以及removeAllTextures()方法移除全部纹理。

TextureCache提供了对纹理的引用计数管理方案，但是在实际游戏中，不同场景间通常会有一些共用的纹理数据。在场景切换时，一方面，我们需要尽量移除不再使用的纹理以节约内存空间，另一方面，需要在进入场景时预加载所有需要的资源。如果只按照引用计数区分资源，会在移除空闲纹理时移除那些新场景中预加载但还未使用的纹理。为了解决这个问题Cocos2d-x维护了一张不同场景各自使用那些资源（包括纹理资源）的表格，从而在进入场景前将对应的资源的引用计数加1，而在离开场景时将对应资源的引用计数减1。


--------------
# 事件分发

**事件**是指在应用程序中由于用户输入或者程序内部的某个处理逻辑完成，需要等待其它模块针对该行为进行一些响应操作的情况，例如玩家单击了屏幕，某个角色血量低于0时触发死亡。Cocos2d-x的事件分发系统是使用订阅者设计模式实现的。

cocos2d-x的**订阅者**对应一个EventListener子类，如果事件处理程序想要响应某个事件，会创建一个对应的EventListener子类的实例。每个EventListener由一个回调函数，一个订阅者类型type，以及一个listerID组成。
